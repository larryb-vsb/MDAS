SchemaWatch – Full Feature Specification
(Neon Postgres-compatible schema change detection & versioning system)
1. Goal
Automatically detect and permanently record every schema-level change (CREATE, ALTER, DROP of tables, indexes, functions, etc.) in a database, and expose a clear, monotonically increasing schema version that any application can read in one query.
2. Scope
Covers all DDL events in a chosen schema (default: public). Works on Neon serverless Postgres (15+).
3. Core Requirements
Zero external tools or extensions required (uses only built-in event triggers)
One-row current version view (for apps to read instantly)
Full immutable audit trail
Survives pg_dump / pg_restore / branching in Neon
Minimal performance impact (< 1 ms overhead per DDL)
4. Database Objects
-- 4.1 The audit table (immutable history)
CREATE TABLE schema_watch.log (
   log_id        bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
   event_time    timestamptz NOT NULL DEFAULT now(),
   schema_name   text NOT NULL,
   object_type   text NOT NULL,
   object_name   text,
   command_tag   text NOT NULL,               -- CREATE TABLE, ALTER TABLE, DROP FUNCTION, etc.
   ddl_command   text,                        -- full SQL command (if < 8 kB)
   statement_uid text NOT NULL,               -- hash to dedupe in branching environments
   version       bigint NOT NULL
);
-- 4.2 Current version view (what apps actually read)
CREATE VIEW schema_watch.current_version AS
SELECT version
FROM schema_watch.log
ORDER BY log_id DESC
LIMIT 1;
-- Optional: materialized version for zero-cost reads
CREATE MATERIALIZED VIEW schema_watch.current_version_mat AS
SELECT version FROM schema_watch.current_version;
CREATE UNIQUE INDEX ON schema_watch.current_version_mat (version);
-- 4.3 Sequence for deterministic versioning (optional but recommended)
CREATE SEQUENCE schema_watch.version_seq;
5. Trigger Function
CREATE OR REPLACE FUNCTION schema_watch.record_ddl()
RETURNS event_trigger
LANGUAGE plpgsql
AS $$
DECLARE
   r record;
   cmd_text text;
   stmt_hash text;
   new_version bigint;
BEGIN
   -- Bump version atomically
   new_version := nextval('schema_watch.version_seq');
   FOR r IN SELECT * FROM pg_event_trigger_ddl_commands() LOOP
       -- Capture the actual command text when available
       BEGIN
           cmd_text := current_query();
       EXCEPTION WHEN others THEN
           cmd_text := NULL;
       END;
       stmt_hash := md5(
           coalesce(r.schema_name,'') || '.' ||
           coalesce(r.object_type,'') || '.' ||
           coalesce(r.object_identity,'') || '.' ||
           coalesce(cmd_text,'')
       );
       INSERT INTO schema_watch.log (
           schema_name, object_type, object_name,
           command_tag, ddl_command, statement_uid, version
       ) VALUES (
           r.schema_name,
           r.object_type,
           r.object_name,
           tg_tag,
           cmd_text,
           stmt_hash,
           new_version
       );
   END LOOP;
   -- Refresh materialized view in same transaction
   REFRESH MATERIALIZED VIEW schema_watch.current_version_mat;
END;
$$;
6. Event Trigger
CREATE EVENT TRIGGER schema_watch_trigger
   ON ddl_command_end
   -- Optional: exclude COMMENT, SECURITY LABEL etc.
   WHEN tg_tag IN (
       'CREATE TABLE', 'ALTER TABLE', 'DROP TABLE',
       'CREATE INDEX', 'ALTER INDEX', 'DROP INDEX',
       'CREATE FUNCTION', 'ALTER FUNCTION', 'DROP FUNCTION',
       'CREATE SCHEMA', 'ALTER SCHEMA', 'DROP SCHEMA',
       'CREATE TYPE', 'ALTER TYPE', 'DROP TYPE',
       'CREATE SEQUENCE', 'ALTER SEQUENCE', 'DROP SEQUENCE',
       'CREATE VIEW', 'ALTER VIEW', 'DROP VIEW'
       -- add more as needed
   )
EXECUTE FUNCTION schema_watch.record_ddl();
7. One-liner for apps to read current version
SELECT version FROM schema_watch.current_version_mat;
-- or the non-materialized view if you prefer zero-maintenance
SELECT version FROM schema_watch.current_version;
8. Initial seeding (run once)
DO $$
BEGIN
   PERFORM setval('schema_watch.version_seq', 1000);  -- start wherever you want
   INSERT INTO schema_watch.log (version, event_time, command_tag, statement_uid, schema_name)
   VALUES (currval('schema_watch.version_seq'), now(), 'SCHEMAWATCH_INIT', 'init', 'public');
   REFRESH MATERIALIZED VIEW schema_watch.current_version_mat;
END$$;
9. Privileges needed (run as superuser or role with CREATE EVENT TRIGGER)
GRANT USAGE ON SCHEMA schema_watch TO your_app_role;
GRANT SELECT ON schema_watch.current_version_mat TO your_app_role;
GRANT SELECT ON schema_watch.log TO monitoring_role;  -- optional
That’s the complete, production-ready SchemaWatch spec.
Copy-paste → deploy → your app just does SELECT version FROM schema_watch.current_version_mat and instantly knows if the schema changed since last time.
Want me to package this as a single migration file?