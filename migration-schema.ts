/**
 * MIGRATION-SAFE SCHEMA - Production Aligned
 * Temporary schema for safe migration without dynamic table prefixing
 * Based on architect guidance to adopt production as source of truth
 */

import { pgTable, text, serial, integer, numeric, timestamp, date, boolean, jsonb, index } from "drizzle-orm/pg-core";

// Production-aligned tables WITHOUT dynamic prefixing

// API Merchants table (Production structure)
export const api_merchants = pgTable("api_merchants", {
  id: text("id").primaryKey(), // Production uses text
  name: text("name"),
  status: text("status"),
  address: text("address"),
  city: text("city"),
  state: text("state"),
  zip_code: text("zip_code"),
  category: text("category"),
  created_at: timestamp("created_at"),
  last_upload_date: timestamp("last_upload_date"),
  client_mid: text("client_mid"),
  other_client_number1: text("other_client_number1"),
  other_client_number2: text("other_client_number2"),
  client_since_date: timestamp("client_since_date"),
  country: text("country"),
  edit_date: timestamp("edit_date"),
  merchant_type: text("merchant_type"),
  sales_channel: text("sales_channel"),
  as_of_date: timestamp("as_of_date"),
  updated_by: text("updated_by"),
  search_index: text("search_index"),
  association: text("association"),
  mcc: text("mcc"),
  master_mid: text("master_mid"),
  bank: text("bank"),
  associate_merchant_number: text("associate_merchant_number"),
  dba_name_cwob: text("dba_name_cwob"),
  cwob_debit_risk: text("cwob_debit_risk"),
  vwob_ebt_return: text("vwob_ebt_return"),
  bypass_ea: text("bypass_ea"),
  bypass_co: text("bypass_co"),
  merchant_record_st: text("merchant_record_st"),
  board_dt: timestamp("board_dt"),
  sale_amt: numeric("sale_amt"),
  credit_amt: numeric("credit_amt"),
  negative_amount: numeric("negative_amount"),
  number_o: text("number_o"),
  bypass_force: text("bypass_force"),
  fee_visa: numeric("fee_visa"),
  visa_mcc: text("visa_mcc"),
  daily_auth_limit: numeric("daily_auth_limit"),
  bypass_ex: text("bypass_ex"),
  excessive_deposit_amount: numeric("excessive_deposit_amount"),
  threshold: numeric("threshold"),
  risk_score: numeric("risk_score"),
  risk_level: text("risk_level"),
  last_risk_assessment: timestamp("last_risk_assessment"),
  risk_flags: text("risk_flags").array(),
  compliance_status: text("compliance_status"),
  review_required: boolean("review_required"),
  risk_notes: text("risk_notes")
});

// Uploaded Files table (Production structure) 
export const uploaded_files = pgTable("uploaded_files", {
  id: text("id").primaryKey(), // Production uses text ID
  filename: text("filename"),
  originalFilename: text("original_filename"),
  filePath: text("file_path"),
  fileSize: integer("file_size"),
  storagePath: text("storage_path"),
  fileType: text("file_type"),
  status: text("status"),
  createdAt: timestamp("created_at"),
  updatedAt: timestamp("updated_at"),
  uploadedAt: timestamp("uploaded_at"),
  processed: boolean("processed"),
  processingErrors: text("processing_errors"),
  deleted: boolean("deleted"),
  // Additional columns to match development
  metadata: jsonb("metadata"),
  businessDay: date("business_day"),
  fileDate: date("file_date"),
  fileContent: text("file_content"),
  mimeType: text("mime_type"),
  processedAt: timestamp("processed_at"),
  processingStatus: text("processing_status"),
  processingStartedAt: timestamp("processing_started_at"),
  processingCompletedAt: timestamp("processing_completed_at"),
  processingServerId: text("processing_server_id"),
  recordsProcessed: integer("records_processed"),
  recordsSkipped: integer("records_skipped"),
  recordsWithErrors: integer("records_with_errors"),
  processingTimeMs: integer("processing_time_ms"),
  processingDetails: text("processing_details"),
  uploadEnvironment: text("upload_environment"),
  rawLinesCount: integer("raw_lines_count"),
  processingNotes: text("processing_notes"),
  processedBy: text("processed_by"),
  tags: text("tags").array(),
  notes: text("notes")
});

// Uploader Uploads table (Both dev/prod use text ID)
export const uploader_uploads = pgTable("uploader_uploads", {
  id: text("id").primaryKey(),
  filename: text("filename"),
  fileSize: integer("file_size"),
  startTime: timestamp("start_time"),
  uploadStartedAt: timestamp("upload_started_at"),
  uploadProgress: integer("upload_progress"),
  chunkedUpload: boolean("chunked_upload"),
  chunkCount: integer("chunk_count"),
  chunksUploaded: integer("chunks_uploaded"),
  uploadedAt: timestamp("uploaded_at"),
  storagePath: text("storage_path"),
  s3Bucket: text("s3_bucket"),
  s3Key: text("s3_key"),
  s3Url: text("s3_url"),
  s3Etag: text("s3_etag"),
  uploadStatus: text("upload_status"),
  identifiedAt: timestamp("identified_at"),
  detectedFileType: text("detected_file_type"),
  userClassifiedType: text("user_classified_type"),
  finalFileType: text("final_file_type"),
  lineCount: integer("line_count"),
  dataSize: integer("data_size"),
  hasHeaders: boolean("has_headers"),
  fileFormat: text("file_format"),
  encodingStartedAt: timestamp("encoding_started_at"),
  encodingCompletedAt: timestamp("encoding_completed_at"),
  encodingTimeMs: integer("encoding_time_ms"),
  encodingStatus: text("encoding_status"),
  jsonRecordsCreated: integer("json_records_created"),
  tddfRecordsCreated: integer("tddf_records_created"),
  fieldSeparationStrategy: text("field_separation_strategy"),
  encodingErrors: jsonb("encoding_errors"),
  healthMetadata: jsonb("health_metadata"),
  compressionUsed: text("compression_used"),
  encodingDetected: text("encoding_detected"),
  validationErrors: jsonb("validation_errors"),
  processingNotes: text("processing_notes"),
  createdBy: text("created_by"),
  serverId: text("server_id"),
  sessionId: text("session_id"),
  keepForReview: boolean("keep_for_review"),
  currentPhase: text("current_phase"),
  lastUpdated: timestamp("last_updated")
});